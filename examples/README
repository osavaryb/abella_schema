(28/05/2013)
Started looking at proof generation. 

Inversion is easy, each block is the same no matter what the other blocks are

Uniqueness has a number of cases of the case H1 dependent on the number of blocks. 
If the term added by the block is the one being compared, then it can be either front or part of the rest,so it looks something like
   case H2
      -h case H3. 
      	        -h search.
		-t prune
      -t case H3.
       	       -h prune 
	       -t IH 

 o.w. it's part of the tail and we just use I.H.
    case H2. case H3. IH

Note for uniqueness: nabla bound variable has to appear in the term if we want this propertie to hold. e.g. block uhoh: exists P. nabla x. path P P won't have a uniqueness lemma.

===========================================================
QUESTION:
Best way to add defn,theorem,proof?
    - reimplement the theorem portion of process
    - push parsed syntax to input
    - as a new tempfile on input_file, pre-lex.

IDEA:
Generic naming of schema by the blocks
Tactic to generate projections of a schema towards another.
  break ctx_oftmpath 2 3 as ctx_tmpath


ADDED SO FAR:
Lexer, Parser, Pretty-Printer for block with 1 exists, 1 nabla, 1 field.
Lexer, Parser, PP for schema with a list of simple block.
Function add_block, get_block in prover.ml to accumulate blocks at defn and get them at schema declaration.


WIP:
working on processing of block in abella.ml

TODO:
working on processing of block in schema.ml

DESC:
Definition should only be carried out at Schema, 
Block should 
-) Get the pred's signature to type id1, id2 (lookup_const sign "of")
-) create the prune theorem if not already done for the type of the nabla bound variable(id2)
-) store the raw block with add_block
(* pseudo: 1) find the var in tt which is nabla bound
           2) match it with its type from pty
	   3) generate pruning lemma theorem for that type
	   3) update nabla, exists bounds with typing information *)


Schema should
-) Create the context definition, one constructor for each of its block plus the nil one
-) Spawm and prove the various theorems about regular contexts.



Meeting:
-Btw, if not Ty([], A) for nabla then throw error
-For prune...

-Once we have dat lemma in (add_schema_lemma), when get to 
apply hyp_name to...
add "schema_lemma" to hypname













