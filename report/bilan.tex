\documentclass[nocopyrightspace,authoryear]{sigplanconf}
%\usepackage{fullpage}
\usepackage{natbib}
\usepackage{filecontents}
\usepackage{proof,enumerate,graphicx}
\usepackage{amsmath, amssymb}
%\usepackage{color}
\usepackage{exscale}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{multicol}
 \usepackage{stmaryrd}
\usepackage{url}
\usepackage{latexsym}
\usepackage{colonequals}

\renewcommand{\t}[1]{{\fontsize{1.0\zzlistingsize}{1.05\zzlistingsize}\texttt{#1}}}

% Set up listings "literate" keyword stuff (for \lstset below)
\newdimen\zzlistingsize
\newdimen\zzlistingsizedefault
\zzlistingsizedefault=8pt
\zzlistingsize=\zzlistingsizedefault
\global\def\InsideComment{0}
\newcommand{\Lstbasicstyle}{\fontsize{\zzlistingsize}{1.05\zzlistingsize}\ttfamily}
\newcommand{\keywordFmt}{\fontsize{0.9\zzlistingsize}{1.0\zzlistingsize}\bf}
\newcommand{\smartkeywordFmt}{\if0\InsideComment\keywordFmt\fi}
\newcommand{\commentFmt}{\def\InsideComment{1}\fontsize{0.95\zzlistingsize}{1.0\zzlistingsize}\rmfamily\slshape}

\newcommand{\LST}{\setlistingsize{\zzlistingsizedefault}}

\newlength{\zzlstwidth}
\newcommand{\setlistingsize}[1]{\zzlistingsize=#1%
\settowidth{\zzlstwidth}{{\Lstbasicstyle~}}}
\setlistingsize{\zzlistingsizedefault}
\renewcommand{\bar}{\overline}

\lstset{literate={->}{{$\rightarrow~$}}2 %
                 {=>}{{$\Rightarrow~$}}2 %
                 {id}{{{\smartkeywordFmt id}}}1 % 3 $~$
                 {\\Gamma}{{$\Gamma$}}1 %
                 {\\Pi}{{$\Pi$}}1 %
                 {\\Sigma}{{$\Sigma$}}1 %
                 {\\Pibox}{{$\Pibox$}}1 %
                 {\\psi}{{$\psi$}}1 %
                 {\\phi}{{$\phi$}}1 %
                 {\\sigma}{{$\sigma$}}1 %
                 {\\gamma}{{$\gamma$}}1 %
                 {mlam}{{$\lambda^{\scriptscriptstyle\Box}$}}1 %
%                 {mlam}{{$\lambda$}}1 %
                 {FN}{{$\Lambda$}}1 %
                 {<<}{\color{dGreen}}1 %
                 {>>}{\color{black}}1 %
               ,
               columns=[l]fullflexible,
               basewidth=\zzlstwidth,
               basicstyle=\Lstbasicstyle,
               keywordstyle=\keywordFmt,
               identifierstyle=\relax,
               xleftmargin=20pt,
%               stringstyle=\relax,
               commentstyle=\commentFmt,
               breaklines=true,
               breakatwhitespace=true,   % doesn't do anything (?!)
               mathescape=true
               }


\title{Automated reasoning with contexts in Abella}


\authorinfo{Olivier Savary-Belanger}
           {McGill University}
           {osavary@cs.mcgill.ca}

% \authorinfo{Kaustuv Chaudhuri}
%            {INRIA Saclay Ile-de-France}
%            {kaustuv.chaudhuri@inria.fr}




\begin{document}
\maketitle
\section{Introduction}
This work aims at simplifying contextual reasoning in Abella.

Abella \cite{abellasys} is an interactive theorem prover developed in a collaboration between INRIA Saclay Ile-de-France and U. of Minnesota. A formal development in Abella consists of:
\begin{itemize}
\item a specification file, where the studied systems and their meta-theory are defined.
\item a reasoning file, where theorems about the specifications are stated and proved using a language of tactics.
\end{itemize}

Abella allows for higher-order reasoning; terms may introduce assumptions to a local context of assumptions. In Abella, such contexts are represented as lists. However, contextual reasoning generally requires a certain number of structural properties of the context which do not hold in general for lists of formulas. For this reason, other systems such as Twelf \cite{twelfsys} and Beluga \cite{belugasys} provide specific facilities to characterize contexts in such a way that the desired proprieties always hold. Instead, Abella users need to define a proposition characterizing what kind of assumption can dynamically extend the context, and prove a number of structural theorems to reason about members of such context. Our main contribution is to automatically prove properties about contexts defined using our facilities.
% lacks specific facilities to define them, such as regular worlds in Twelf \cite{twelfsys} and schemas in Beluga \cite{belugasys}. 


\section{The Schema Plugin}

We developed a plugin for Abella introducing Schema, which restricts regular contexts definition to a fragment of inductive definitions available in Abella, and tactics automatically proving and applying theorems which always hold for context defined in our fragment. We will use the definition and lemmas about the context relation \lstinline|ctx2|, used in \lstinline|bredure|, from the Abella example suite, as a working example.

\begin{lstlisting}
kind tm   type.
...
kind p type.
...
type bred tm -> tm -> o.
type path tm -> p -> o.
type bfree tm -> o.
\end{lstlisting}
\begin{lstlisting}
Define ctx2 : olist -> olist -> prop by
  ctx2 nil nil
; nabla n p,
    ctx2 (bred n n :: G) (path n p :: D) := 
      ctx2 G D
; nabla n,
    ctx2 ((pi u\ bred M u => bred n u) :: G)
         ((pi q\ path M q => path n q) :: D) :=
      ctx2 G D.
\end{lstlisting}

%Top_command
Contexts, as defined in our plugin, can be described as zero or more applications of a finite sum of clauses, each of which adds a formula to a context of the same schema. We restrict the quantification of variables in the formulas to a series of existential quantifiers ($\exists$) followed by $\nabla$s. N-ary context relations, where formulas (potentially depending on the same variables) are introduced simultaneously in  $n$ different contexts, can also be represented using our extension. N-ary context relations are represented using n lists of formulas, each clause corresponding to a constructor stating that, given such context relations, adding the formulas in the clauses in front of their respective list relate the extended lists. An additional constructor corresponding relating empty contexts is added to every context relation. The grammar of the schema definitions follows.


\begin{lstlisting}
OPTEXISTS :=
  | exists <ID LIST>, 
  |

OPTNABLAS :=
  | nabla <ID LIST>,
  |

CBODY :=
  | <TERM>, <CBODY>
  | <TERM>

CLAUSE :=
  | <OPTEXISTS> <OPTNABLAS> ( <CBODY> )
  | <OPTEXISTS> <OPTNABLAS> <TERM>

TOP_COMMAND :=
  | Schema <SCH-NAME> := <CLAUSE>
\end{lstlisting} 


The definition of \lstinline|ctx2| as a context relation schema is given below.

\begin{lstlisting}
Ctx !
Schema ctx2 := nabla n p, (bred n n, path n p);
               exists M, nabla n, 
                 ((pi u\ bred M u => bred n u), 
                 (pi q\ path M q => path n q)). !
\end{lstlisting}


%Command

The grammar for the tactics supported by our plugin follows.

\begin{lstlisting}
COMMAND :=
  | inversion <HYP-NAME> <HYP-NAME>
  | sync      <HYP-NAME> <HYP-NAME>
  | unique    <HYP-NAME> <HYP-NAME> <HYP-NAME>
  | projas ( <TERM> )  <HYP-NAME>
\end{lstlisting}

The tactics introduced by our plugin are:
\begin{itemize}
\item Inversion, which states that we can characterize members of the contexts by one of the clauses which could have introduced them. The inversion theorems we generate also provide informations about the nominal nature of the $\nabla$-bound variables, and about the formulas introduced in the other projections of the context relation.

\begin{lstlisting}
Theorem ctx2_inversion_G :
forall G D F,
  ctx2 G D -> member F G ->
  ((exists N P, 
    member (path N P) D $\wedge$
    F = bred N N $\wedge$  
    name_p P $\wedge$ name_tm N)
  $\vee$
   (exists M N, 
    member (pi q\ path M q => path N q) D $\wedge$ 
    F = (pi u\ bred M u => bred N u) $\wedge$  
    fresh_tm_in_tm N M)).
intros Hctx  Hmem. 
Ctx ! inversion Hctx Hmem.! 
search.
\end{lstlisting}

\item Synchronize, which states that given a member of a context in a context relation, clauses which could have introduced that term introduced at the same time corresponding members in the other projections of the context relation.
\begin{lstlisting}
Theorem ctx2_synchronize :
  forall G D M N,
  ctx2 G D ->
  member (pi u\ bred M u => bred N u) G ->
  (member (pi q\ path M q => path N q) D $\wedge$ 
   fresh_tm_in_tm N M).
intros Hctx Hmem. 
Ctx ! sync Hctx Hmem. ! 
search.
\end{lstlisting}

\item Unique, which states that two members of a context sharing nominal variables should be equal. This is because we restrict the logical variables to be bound before the nominal variables introduced in each clauses, such that a particular nominal variable can only appear in a single instance of a clause in a context relation.   

\begin{lstlisting}
Theorem member_D_unique :
   forall G D X Y N,
   ctx2 G D ->
   member (pi q\ path X q => path N q) D ->
   member (pi q\ path Y q => path N q) D ->
   X = Y.
intros Hctx Hmem1 Hmem2. 
Ctx ! unique Hctx Hmem1 Hmem2. ! 
search.
\end{lstlisting}

\item Projection, which helps reusing contexts in different context relations by verifying and applying transformation (projections and injections) theorems between context relations. The $i$th context relations \lstinline|S| can be used as the $j$th projection of a context relations \lstinline|S'| if, for each clauses \lstinline|C| of \lstinline|S|, there exists a clause \lstinline|C'| of \lstinline|S'| s.t. the $i$th formula of \lstinline|C| matches the $j$th formula of \lstinline|C'|, which is to say that the $j$th projection of the schema \lstinline|S'| is more general than the $i$th projection schema \lstinline|S| .
\begin{lstlisting}
Ctx !
Schema bctx := exists M, nabla n, 
                  (pi u\ bred M u => bred n u);
               exists n n', bred n n'. !


Theorem ctx2ToBctx: forall E D, ctx2 E D -> bctx E.
intros Hctx. 
Ctx ! projas (bctx E) Hctx. ! 
search.

Ctx ! Schema pctx := nabla n p, path n p. !.

Theorem pctxToCtx2: forall D, pctx D -> (exists E, ctx2 E D).
intros Hctx. 
Ctx ! projas (ctx2 E D) Hctx. ! 
search.

\end{lstlisting}


\end{itemize}

\section{Discussion and Conclusion}
Our tactics eliminate the need for most of the boilerplate lemmas present in the developments from the Abella example suite. For example, using our plugin to rewrite the $bredure$ example eliminates half of the lines of code in the reasoning ($.thm$) file. As additional context relations and mappings between context relations are present in bigger developments, we believe the provided tactics can significantly reduce the size of Abella developments using reasoning with contexts.

All the theorems proved by the tacticals could be proven at the moment of schema definition (or at the second schema definition in the case of projection). To reduce the number of theorems polluting the environment, we state and prove them only as needed, selecting the required theorem by observing the assumptions applied to the tactics. Proven theorems are kept until the end of the proof in which the tactical was used to avoid having to reprove them, for example in the case of repetitive application of a tactic to similar hypothesis. Each theorem can be named by stating it and using a tactical to prove it, as shown in each of the included example use of tacticals.

%Related work
An important design decision of our development is that the theorem generated are proven using the primitive tactics of Abella, and verified as regular theorems. Consequently, no logical inconsistency could have been introduced by our plugin. This contrasts with theorem provers providing primitive notions of context, such as Twelf \cite{twelfsys} and Beluga \cite{belugasys}, where the properties proven with our tactics are part of the trusted code base.

%Plugin extension
The extension we describe adds both top level commands and tactics to Abella. Instead of modifying the parser and main function to support the new functionality, we devised a plugin framework where an arbitrary expression can be dispatched to a particular plugin from an Abella source file. Plugins are implemented as modules implementing a processing function for strings received from the top level of the source file, and another processing function for strings received as reasoning command. Each processing function receives a function which allows to recursively process strings as if their appeared in their respective position in the source file. The processing function at the reasoning command level also receives a copy of the current goal and hypothesis, which are updated by their recursing function. This can be related to tactical languages such as Ltac \cite{ltacpap}, which can be used to develop Coq procedures applying tactics in function of current goal. In comparison, we allow arbitrary, potentially unsafe Ocaml code in the plugins, with the restriction that the only entry point back in the prover is the passed function. In the future, one would like to provide functions for plugins to safely interact with the prover, which could culminate in a language to define extensions and tacticals from within Abella source files. 


\bibliographystyle{abbrvnat}

\bibliography{summer}


\end{document}
