Documentation for the tacticals introduced in Abella's schema extension.
by Olivier Savary

  -----------
 | INVERSION |
  -----------
Description: Inversion states that, for a variable E of some projection of a schema, E be of the forms introduced by the clauses of the schema of the context, and, members introduced in other projections at the same time must also be present in their respective projection.

Syntax:
	apply inv to H1 H2 

	where H1: ctxName G1 ... Gm
	      H2: member V Gi


High-level overview:
inv.1 > verify that 
      	         hyp1 = ctxName G1 ... Gn
                 hyp2 = member V Gi
        for defined ctxName of arrity n, 1 < i < n,  and a logic variable V
inv.2 > See if a proof of inv was already done for that schema, for the same projection of the schema. If it is the case, return that schema name, otherwise continue.
inv.3 >  make inv statement & proof corresponding to the schema ctxName, for an element E at the ith projection

Naming: "Hinv"^[ name of the schema]^[ projection of the schema at which invert ]

Statement:
Disjunction of, for each of the clauses of the schema, 
    Conjunction of, for every nabla and exists bound variable of the clause, fresh/name lemmas, and for each of the projections of the clauses,
      On ith projection, E is of the form introduced by the block.
      On any other projection, assert that a term of the form introduced by the projection of that clause is present in the right projection of the schema.
 

Proof:
By induction on the size of the projection of the schema. 
  If 0, then case-analysis on the membership relation to reveals that E can't be a member of an empty Gi.
  otherwise case-analyse the membership relation, 
      either it corresponds to the first element in the context, close with search.
      or it doesn't, apply I.H. on the rest of the context. If the context has many clauses, I.H. will return a disjunction, case-analyse it and close each with search, otherwise close with search.


 -----------
|    SYNC   |
 -----------
Description: Sync states that, for particular term E, member of some projection of a schema to have a certain form, it must have been introduced by one of the clauses which matches the form of E, s.t. members introduced in other projections at the same time must be present in their respective projections.

Syntax:
	apply sync to H1 H2 

	where H1: ctxName G1 ... Gm
	      H2: member E Gi


High-level overview:

 syn.1 > verify that
       	 	  hyp1 = ctxName G1 ... Gn
                  hyp2 = member E[X1,...Xm] Gi
         for defined ctxName of arrity n,  1 < i < n, and some E:o.
 syn.2 > see which blocks, from the ith projection of ctxName, could match E
 syn.3 > See if a proof of sync was already done for that schema, for a statement matching the same clauses. If it is the case, return that schema name, otherwise continue.
 syn.4 > unify all the matched blocks as T
 (syn.4'> use E directly as T )
 syn.5 > make sync statement & proof, asserting equality for each variables shared by the ith projection and the rest of the clause.

Naming: "Hsync"^[name of the schema]^[projection of the schema at which we sync ]^[ bitmap of matched blocks ]

Statement:
Disjunction of, for each of the clauses matching E,
	   Conjuction, for j between 1 and n, not equal to i, of the membership assumption "member Ej Gj" and of freshness assumptions for the variables present in the clause.

Proof:
By induction on the size of the projection of the schema. 
  If 0, then case-analysis on the membership relation to reveals that E can't be a member of an empty Gi.
  otherwise case-analyse the membership relation, 
     for each clauses in the schema,
         if the term could've been introduced by the clause, then either it's the first element, in which case search, o.w. I.H. and search
         o.w. can't be the first element, so apply I.H. and search.




 -----------
|   UNIQUE  |
 -----------
Description: Unique states that, if two members of a projection of a schema are equal on a nabla-bound variable, the other variables (both nabla and exists bound) from the relevant block(s) must also be equal.

Syntax: 
	apply unique to H1 H2 H3 

	where H1: ctxName G1 ... Gm
	      H2: member E1 Gi
	      H3: member E2 Gi


High-level overview:
 uni.1 > verify that 
         	  hyp1 = ctxName G1 ... Gn
                  hyp2 = member E1 Gi
                  hyp3 = member E2 Gi
         for defined schema ctxName of arrity n and  1 < i < n, and some E1:o and E2:o
 uni.2 > see & get which variables are equal and in the same position in E1 and E2.
 uni.3 > unify E1 and E2 as E
 uni.4 > see which clauses of ctxName's ith projection matches E
 uni.5 > find, from the equal variables, a variable N which is nabla bound in every clauses matched by E. 
 uni.6 > See if a proof of unique was already done for that schema, ground on the same variables, for a statement matching the same clauses. If it is the case, return that schema name, otherwise continue uni.
 uni.7 > unify all the matched pattern as pE
 ( uni.7' > use E as pE directly  )
 uni.8 > making unique statement&proof corresponding to N for pE

Naming: "Huni"^[name of the schema]^[projection of the schema at which unique is created]^[ground variable in the first matched block]^[ bitmap of matched blocks ]

Statement:
...

Proof:
...



 -----------
|   PROJ    |
 -----------
Description: ...

Syntax: 
	"apply projas (ctxNameD D1 ... Dn) to H"
	
	where H:ctxNameO G1 ... Gm


High-level overview:
 pro.1 > verify that  str =  ctxNameD D1 ... Dn (for some i1 ... im between 1 and n)
                      hyp1 = ctxNameO G1 ... Gm
         for some defined schema ctxNameO of arrity m and ctxNameD of arrity n.
pro.2 > verify if a block mapping the same projections in ctxName to the same proj in ctxNameD was already proven
pro.3 > verify that, for each clause C of ctxName, (Gi1, ..., Gim) in C matches a clause in ctxNameD. To do this,
      a) for each clauses in the origin context, construct a list of constraints of type (id, tm), where the tm corresponds to the unification of all projections of that clauses, which are refered to as id.
      b) for each created list of constraints, check that there exists a clause in the destination context which matches all of them.
pro.4 > (rewrit ewith inj) make statement and proof that \forall G1 ... Gn,ctxName G1 ... Gn -> ctxNameD Gi1 ... Gim

Naming: "Hpro"^[name of the schema of origin]^[ map of the position in the destination context for each projection of the origin schema]^[name of the destination schema]

Statement:
Function to go from the origin context to the destination context. Projections of the origin context are universally quantified over, while projections of the destination context not included in the origin context are existentially quantified.

Proof:
Proof goes by induction on the length of the projection of the original schema. 
 if 0, then nil which is in both schema, close with search
 otherwise, for every clauses in the schema, apply the I.H. to the rest of the context, and search (for the right clause in the destination schema which matches the top element).
